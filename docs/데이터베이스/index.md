---
sidebar_position: 4
---

# 인덱스

인덱스(Index)는 데이터베이스에서 검색 성능을 향상시키기 위해 사용하는 자료 구조입니다.  
인덱스를 활용하면 특정 데이터를 찾는 시간이 단축되지만, 추가적인 저장 공간이 필요하고 데이터 삽입·삭제 시 성능 저하가 발생할 수 있습니다.

## B-트리 (Balanced Tree)
![프로세스의 상태](/img/b-tree.png)

B-트리(Balanced Tree)는 인덱스를 구성하는 가장 일반적인 자료 구조로, **균형 잡힌 트리 구조**를 유지하며 데이터 검색, 삽입, 삭제 성능을 최적화합니다.  
B-트리는 **균형 유지**, **최소한의 디스크 I/O**, **빠른 탐색**을 보장하는 특징을 가집니다.

### B-트리 구조
B-트리는 다음과 같은 노드들로 구성됩니다.

- **루트 노드(Root Node)**: 트리의 최상단에 위치하며, 최소 2개 이상의 자식 노드를 가짐.
- **브랜치 노드(Branch Node)**: 중간 노드로,데 이터와 자식 노드를 포함.
- **리프 노드(Leaf Node)**: 최하단 노드로, 실제 데이터가 저장되며 자식 노드가 없음.

### B-트리의 동작 원리

1. **탐색(Search)**
   - 루트 노드에서 시작하여 키 값을 비교하며 브랜치 노드를 따라 내려감.
   - O(log N) 시간 복잡도로 원하는 데이터를 찾을 수 있음.

2. **삽입(Insertion)**
   - 새로운 키를 적절한 위치에 삽입.
   - 노드가 가득 차면 노드를 분할(Split)하여 균형을 유지.

3. **삭제(Deletion)**
   - 데이터를 삭제한 후, 언더플로우(Underflow, 최소 키 개수 미만)가 발생하면 병합(Merge) 수행.

### B-트리의 효율성

- **균형 유지**: 노드 분할 및 병합을 통해 트리 깊이를 일정하게 유지.
- **디스크 I/O 최소화**: 한 노드에 여러 개의 키 값을 저장하여 디스크 접근 횟수 감소.
- **로그 시간 탐색**: O(log N) 시간 복잡도로 빠른 검색, 삽입, 삭제 가능.

## 인덱스의 종류

### 1. **클러스터형 인덱스(Clustered Index)**
- 테이블의 **기본 데이터 자체가 인덱스 순서에 따라 정렬**됨.
- 테이블당 **하나만 생성 가능**.
- 기본 키(Primary Key)가 설정되면 자동으로 클러스터형 인덱스가 생성됨.

### 2. **보조(세컨더리) 인덱스(Secondary Index)**
- 클러스터형 인덱스와 별도로 존재하는 인덱스.
- 데이터를 정렬하지 않고, 특정 컬럼을 기반으로 검색 속도를 향상.


## 인덱스 최적화 기법
1. 인덱스는 비용이다
    - 인덱스는 저장 공간을 차지하고, 데이터 변경 시 추가적인 비용이 발생함.
    - 모든 컬럼에 인덱스를 생성하는 것은 비효율적이므로 조회 빈도가 높은 컬럼에만 설정.

2. 인덱스 생성 후 반드시 성능 테스트
    - `EXPLAIN` 명령어를 사용하여 인덱스가 적절히 사용되고 있는지 확인.

3. 복합 인덱스 생성 시 순서 고려
    - 인덱스 생성 순서가 중요하며, 보통 다음과 같은 순서로 구성.
        1. 같음(Equal) 비교 연산이 있는 컬럼
        2. 정렬(Sort) 연산이 필요한 컬럼
        3. 범위(Range) 연산을 수행하는 컬럼 (>, < 등)
        4. 카디널리티(중복도가 낮은 컬럼) 높은 컬럼
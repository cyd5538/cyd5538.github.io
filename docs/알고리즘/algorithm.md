---
sidebar_position: 1
---

# 알고리즘

## 알고리즘이란?
주어진 문제를 해결하거나 함수를 계산하기 위해 따라야 할 명령어들을 단계적으로 나열한 것

## 알고리즘을 만족해야 하는 조건
1. **입력**: 알고리즘은 최소한 0개 이상의 입력을 받아야 합니다.
2. **출력**: 알고리즘은 적어도 1개 이상의 결과를 출력해야 합니다.
3. **명확성**: 알고리즘의 각 단계는 명확하고 모호함이 없어야 합니다.
4. **유한성**: 알고리즘은 유한한 단계 안에 문제를 해결하고 종료되어야 합니다. 단계의 수는 유한하며, 각 단계마다 문제의 크기는 줄어들어야 합니다.
5. **효율성**: 알고리즘의 모든 연산은 충분히 단순하여 사람이 유한한 시간 안에 수행할 수 있을 정도로 단순해야 합니다.
  
## 알고리즘의 표현 방법
알고리즘의 표현 방법에는 대표적으로 3가지가 있습니다. 최솟값 찾는 알고리즘을 예시를 통해 알아봅시다.

1. 수도코드(Pseudocode): 프로그래밍 언어의 문법을 따르지 않는 일종의 가상 코드입니다.

```c
function findMinValue(list)
    minValue = list[0]
    for each element in list
        if element < minValue
            minValue = element
    return minValue
```

1. 순서도: 알고리즘을 그림으로 그려서 순서로 표현하는 방법입니다.

```
시작
└─> 리스트의 첫 번째 요소를 최솟값으로 설정
└─> 각 요소에 대해 반복
    └─> 현재 요소가 최솟값보다 작으면 최솟값을 해당 요소로 업데이트
└─> 반복 종료
└─> 최솟값 반환
종료
```

1. 프로그래밍 언어(JS): 알고리즘을 직접 프로그래밍 언어로 구현하는 방법입니다.

```jsx
function findMinValue(list) {
    let minValue = list[0];
    for (let i = 1; i < list.length; i++) {
        if (list[i] < minValue) {
            minValue = list[i];
        }
    }
    return minValue;
}

```

## 알고리즘 분석
- 정확성 분석
    - 알고리즘이 유효한 입력에 대해 유한 시간 내에 정확한 결과를 생성하는지를 검증하는 과정
        수학적 기법을 사용한 이론적인 증명 과정을 거칩니다
        
- 효율성 분석
    - 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정하고 평가하는 과정
    - 공간 복잡도
        알고리즘이 실행될 때 사용하는 메모리의 양을 측정합니다 정적 공간 + 동적 공간(실행 도중 할당되는 메모리)을 합산한 결과입니다.
    - 시간 복잡도
        알고리즘의 실행 시간을 측정합니다. 알고리즘이 시작부터 완료될 때까지 걸리는 시간입니다.

## 시간복잡도
각 문장이 실행되는 횟수에 의해 결정됩니다. 
- 입력 크기: 일반적으로 입력의 크기가 커질수록 알고리즘의 수행 시간도 증가
- 입력 데이터의 상태: 입력 데이터의 초기 상태나 패턴에 따라 알고리즘의 동작이 달라질 수 있습니다.
일반적으로 알고리즘의 시간복잡도는 수행시간의 최악의 수행시간으로 표현합니다.

## 접근 성능
입력 크기가 무한히 커짐에 따라 결정되는 성능
수행시간의 다항식 함수에서 최고차항만을 계수 없이 취해서 단순하게 표현하는 방법
- 수행시간의 증가 추세를 파악하기 쉬움
- 어떤 알고리즘이 더 효율적이고 최적인지 파악하기 쉬움
접근적 성능 예시
시간 복잡도가 O(n^2)이라면 알고리즘의 수행 시간이 입력 크기 n의 제곱에 비례하여 증가함

**접근 성능 표기법**
- O-표기(“Big-oh”) → 점근적 상한 → 알고리즘의 최악의 수행시간에 해당
- Ω-표기(“Big-omega”) → 점근적 하한 → 최선의 수행시간에 해당
- Θ-표기(“Big-theta”) → 점근적 상한과 하한을 동시에 표시

일반적으로 빅오(Big-O) 표기법이 가장 많이 사용
![image](https://github.com/cyd5538/cyd5538.github.io/assets/91642972/605d4e77-c0e7-4d6d-9e46-95862d1c6220)

 O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2n)

알고리즘의 시간 복잡도를 결정할 때 가장 일반적인 방법 중 하나는 루프의 반복 횟수를 조사

**순환 알고리즘의 성능**
알고리즘 수행 과정에서 자기 자신을 호출하는 형태 순환알고리즘의 성능은 점화식으로 표현되고 이를 풀어서 폐쇄형으로 표시

기본적인 점화식과 폐쇄형

① T(n) = T(n-1) + Θ(1), T(1)=Θ(1) → T(n) = Θ(n)  
② T(n) = T(n-1) + Θ(n), T(1)=Θ(1) → T(n) = Θ(n2) → 퀵 정렬의 최악 수행 시간  
③ T(n) = T(n/2) + Θ(1), T(1)=Θ(1) → T(n) = Θ(logn) → 이진 탐색의 수행 시간  
④ T(n) = T(n/2) + Θ(n), T(1)=Θ(1) → T(n) = Θ(n)  
⑤ T(n) = 2T(n/2) + Θ(1), T(1)=Θ(1) → T(n) = Θ(n)  
⑥ T(n) = 2T(n/2) + Θ(n), T(1)=Θ(1) → T(n) = Θ(nlogn) → 퀵 정렬의 최선 수행 시간, 합병 정렬의 수행 시간

---
sidebar_position: 2
---

# 메모리

CPU는 그저 **메모리**에 올라와 있는 프로그램의 명령어들을 실행할 뿐입니다. 따라서 메모리 구조와 관리 방식은 컴퓨터 성능에 큰 영향을 미칩니다.

## 메모리 계층
컴퓨터의 메모리는 속도와 용량에 따라 **계층적인 구조**로 되어 있습니다.

- **레지스터**: CPU 내부에 있는 작은 메모리로, 가장 빠르지만 용량이 매우 적습니다. (휘발성)
- **캐시(Cache)**: CPU와 RAM 사이에 위치하며, 속도가 빠르지만 용량이 제한적입니다. (휘발성)
- **주기억장치(RAM)**: 실행 중인 프로그램과 데이터를 저장하며, 속도는 보통입니다. (휘발성)
- **보조기억장치(HDD, SSD)**: 가장 느리지만 대용량 데이터를 저장할 수 있습니다. (비휘발성)

:::note
계층 구조에서 **위로 갈수록 속도는 빨라지지만 가격이 비싸지고 용량이 작아집니다.**  
예를 들어, CPU 캐시는 빠르지만 용량이 적고, SSD는 용량이 크지만 속도가 상대적으로 느립니다.
:::

### 캐시(Cache)
캐시는 **자주 사용하는 데이터를 미리 저장하여 속도 차이를 줄이는 임시 저장소**입니다.  
CPU와 RAM 사이의 속도 차이를 해결하기 위해 **L1, L2, L3 캐시**가 존재합니다.

### 지역성의 원리
캐시의 성능을 높이려면 **자주 사용하는 데이터를 저장하는 것이 중요**합니다.  
이를 결정하는 기준이 **지역성(Locality) 원리**입니다.

- **시간 지역성(Temporal Locality)**: 최근 사용한 데이터를 다시 사용할 가능성이 높습니다.
- **공간 지역성(Spatial Locality)**: 최근 접근한 데이터 주변의 데이터도 함께 사용할 가능성이 높습니다.

```js
let i = 0;
for (let j = 0; j < 10; j++) {
    i += 1; // 'i'는 반복적으로 사용됨 → 시간 지역성
}
```

### 캐시미스와 캐시히트
- **캐시 히트**: CPU가 원하는 데이터가 캐시에 존재 → 빠른 접근 가능
- **캐시 미스**: 캐시에 데이터가 없어 RAM에서 가져와야 함 → 속도 저하 발생

### 캐시 매핑
캐시는 크기가 제한적이므로, 어떤 데이터를 저장할지 결정하는 캐시 매핑 기법이 필요합니다.
- **직접 매핑(Direct Mapping)**: 특정 메모리 주소가 특정 캐시 블록에 매핑됨.
- **연관 매핑(Associative Mapping)**: 어떤 캐시 블록에도 저장 가능.
- **집합 연관 매핑(Set-Associative Mapping)**: 직접 매핑과 연관 매핑의 절충 방식.

### 웹 브라우저의 캐시
웹 브라우저에도 캐시가 존재하여, 불필요한 데이터 요청을 줄이고 성능을 향상시킵니다.
| 종류  | 설명  | 
|--------|--------|
| 쿠키(Cookie)    | 만료 기한이 있는 키-값 저장소 (4KB)    | 
| 로컬 스토리지(Local Storage)    | 만료 기한이 없는 키-값 저장소 (10MB)    | 
| 세션 스토리지(Session Storage)   | 현재 세션 동안 유지되는 키-값 저장소 (5MB)    | 

쿠키는 보안 이슈가 발생할 수 있으므로, **HttpOnly 및 Secure 옵션을 설정**하는 것이 중요합니다.

## 메모리 관리
운영체제의 중요한 역할 중 하나는 **한정된 메모리를 효율적으로 관리**하는 것입니다.

### 가상 메모리(Virtual Memory)
가상 메모리는 실제 RAM 크기보다 더 큰 메모리를 제공하는 기술입니다.
- **가상 주소(Virtual Address)**: 프로그램이 인식하는 메모리 주소
- **물리 주소(Physical Address)**: 실제 RAM에서 할당된 주소
- **페이지 테이블(Page Table)**: 가상 주소와 물리 주소를 매핑하는 구조
- **TLB(Translation Lookaside Buffer)**: 페이지 테이블의 일부를 저장하는 캐시 → 속도 향상

### 스와핑(Swapping)과 페이지 폴트(Page Fault)
- **스와핑**: 자주 사용하지 않는 데이터를 HDD로 이동하여 RAM을 확보하는 과정.
- **페이지 폴트**: 실행 중인 프로세스가 **RAM에 없는 데이터에 접근할 때 발생** → HDD에서 데이터를 로드해야 하므로 성능 저하.
```
1. CPU가 필요한 데이터를 RAM에서 찾지 못하면 → 페이지 폴트 발생
2. 운영체제가 HDD에서 데이터를 가져와 RAM에 로드
3. CPU가 다시 실행을 계속함
```

### 스레싱
스레싱은 **과도한 페이지 폴트로 인해 CPU가 메모리 로딩에만 시간을 소비하는 현상**입니다.
이를 방지하기 위해 작업 세트(Working Set) 관리와 페이지 폴트 빈도(Page Fault Frequency, PFF) 조절이 필요합니다.

## 메모리 할당 
프로세스가 실행될 때, 운영체제는 메모리를 연속할당(Contiguous Allocation) 또는 불연속할당(Non-contiguous Allocation) 방식으로 할당합니다.

### 연속 할당 (Contiguous Allocation)
- 고정 분할 방식: 미리 정해진 크기로 메모리를 나눔 → 내부 단편화(Internal Fragmentation) 발생
- 가변 분할 방식: 프로그램 크기에 맞게 동적으로 할당 → 외부 단편화(External Fragmentation) 발생
### 불연속 할당 (Non-contiguous Allocation)
- 페이징(Paging): 동일한 크기의 페이지 단위로 나누어 관리 → 내부 단편화 해결, 주소 변환 필요
- 세그멘테이션(Segmentation): 논리적 의미 단위(코드, 데이터, 스택 등)로 나누어 관리연속 할당
    
### 페이지 교체 알고리즘(Page Replacement Algorithm) 
| 알고리즘  | 설명  | 
|----|--------|
| FIFO    | 	가장 오래된 페이지를 교체   
| LRU    | 가장 오랫동안 사용되지 않은 페이지를 교체   
| NUR   | 	최근 참조되지 않은 페이지를 교체    
| LFU   | 	가장 적게 사용된 페이지를 교체   

최적의 교체 알고리즘은 미래에 어떤 페이지가 필요할지 알아야 하지만, 현실적으로 불가능합니다.
따라서 **LRU나 LFU 같은 근사적인 방법을 사용**합니다.